/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.0 .\public\horizontalTankModel\2Pales\horizontalTank2Blades.glb 
*/

import { useGLTF } from "@react-three/drei";
import { useSpring, animated } from "@react-spring/three";
import CallOutText from "./CallOutText";

export function Model({
  encoderData,
  milkQuantityData,
  switchStatus,
  weightData,
  tankTemperaturesData,
  airQualityData,
}) {
  const { nodes, materials } = useGLTF(
    "./horizontalTankModel/2Pales/horizontalTank2Blades.glb"
  );

  const getRotationDuration = (encoderData) => {
    if (encoderData === null || encoderData <= 0) return 0; // Duración máxima si encoderData es nulo o menor o igual a cero
    const minDuration = 1000; // Duración mínima (animación rápida)
    const maxDuration = 10000; // Duración máxima (animación lenta)
    const minRPM = 0; // RPM mínimo
    const maxRPM = 100; // RPM máximo

    const rpm = Math.min(Math.max(encoderData, minRPM), maxRPM); // Asegurarse de que rpm esté en el rango
    const duration =
      maxDuration -
      ((rpm - minRPM) * (maxDuration - minDuration)) / (maxRPM - minRPM);

    return duration;
  };

  const getVisibleMilkCilinder = (quantity) => {
    const ranges = [
      { min: 0, max: 10, node: nodes.MilkCilinder10 },
      { min: 10, max: 20, node: nodes.MilkCilinder20 },
      { min: 20, max: 30, node: nodes.MilkCilinder30 },
      { min: 30, max: 40, node: nodes.MilkCilinder40 },
      { min: 40, max: 50, node: nodes.MilkCilinder50 },
      { min: 50, max: 60, node: nodes.MilkCilinder60 },
      { min: 60, max: 70, node: nodes.MilkCilinder70 },
      { min: 70, max: 80, node: nodes.MilkCilinder80 },
      { min: 80, max: 90, node: nodes.MilkCilinder90 },
      { min: 90, max: 100, node: nodes.MilkCilinder100 },
    ];

    // Encontrar el rango adecuado para la cantidad
    const range = ranges.find(
      ({ min, max }) => quantity >= min && quantity < max
    );

    if (range && range.node) {
      return (
        <mesh
          geometry={range.node.geometry}
          material={materials["MilkMaterial.003"]}
          position={[-0.026, 1.597, -0.096]}
          scale={[2.531, 2.531, 2.615]}
        />
      );
    }

    return null;
  };

  const getAlcalineAcidCylinders = ({ quantity, maxValue }) => {
    // Calcula los valores de morphTargetInfluences en función de la cantidad y el máximo
    const calculateMorphTargets = (quantity, maxValue) => {
      const percentage = Math.min(quantity / maxValue, 1); // Normaliza el porcentaje (máx 100%)
      
      // Ejemplo: dividir el porcentaje entre tres influencias para simular la variación
      const morph1 = percentage * 0.5; // Primera influencia recibe 50% del porcentaje
      const morph2 = percentage * 0.3; // Segunda influencia recibe 30%
      const morph3 = percentage * 0.2; // Tercera influencia recibe 20%
      
      return [morph1, morph2, morph3];
    };
  
    const alcalineMorph = calculateMorphTargets(quantity, maxValue); // Morph para AlcalineCilinder
    const acidMorph = calculateMorphTargets(quantity, maxValue); // Morph inverso para AcidCilinder
  
    return (
      <>
        <mesh
          name="AlcalineCilinder"
          geometry={nodes.AlcalineCilinder.geometry}
          material={materials["MilkMaterial.003"]}
          morphTargetDictionary={nodes.AlcalineCilinder.morphTargetDictionary}
          morphTargetInfluences={alcalineMorph} // Valores dinámicos
          position={[1.265, -0.001, 2.908]}
          scale={[0.188, 0.015, 0.188]}
        />
        <mesh
          name="AcidCilinder"
          geometry={nodes.AcidCilinder.geometry}
          material={materials["MilkMaterial.003"]}
          morphTargetDictionary={nodes.AcidCilinder.morphTargetDictionary}
          morphTargetInfluences={acidMorph} // Valores dinámicos inversos
          position={[2.112, -0.001, 3.149]}
          scale={[0.188, 0.015, 0.188]}
        />
      </>
    );
  };

  const rotationBlade1 = useSpring({
    loop: true,
    to: { rotation: [0, Math.PI * 2, 0] },
    from: { rotation: [0, 0, 0] },
    config: { duration: getRotationDuration(encoderData?.value ?? 0) },
  });

  const rotationBlade2 = useSpring({
    loop: true,
    to: { rotation: [0, -Math.PI * 2, 0] },
    from: { rotation: [0, 0, 0] },
    config: { duration: getRotationDuration(encoderData?.value ?? 0) },
  });

  const { rotation: rotationHatch } = useSpring({
    to: {
      rotation:
        switchStatus?.status || false ? [-Math.PI / 2, 0, 0] : [0, 0, 0],
    },
    config: { duration: 1000 },
  });

  return (
    <group dispose={null}>

      {getVisibleMilkCilinder(milkQuantityData?.milkQuantity ?? 0)}
      {getAlcalineAcidCylinders({quantity: weightData?.weight ?? 0, maxValue: 35000 })}
      {/* Palas del tanque */}
      <animated.mesh
        geometry={nodes.Blade2.geometry}
        material={materials["BladeMaterial.002"]}
        position={[0, 0.737, 0.918]}
        scale={-0.148}
        rotation={rotationBlade1.rotation}
      />
      <animated.mesh
        geometry={nodes.Blade1.geometry}
        material={materials["BladeMaterial.002"]}
        position={[0, 0.737, -0.982]}
        scale={-0.148}
        rotation={rotationBlade2.rotation}
      />

      <animated.mesh
        geometry={nodes.Hatch.geometry}
        material={materials["HatchMaterial.002"]}
        position={[0, 2.377, -0.206]}
        rotation={rotationHatch}
      />
      <mesh
        geometry={nodes.TankCilinder.geometry}
        material={materials["TankMaterial.002"]}
        position={[0.548, 0.399, -1.476]}
      />
      <mesh
        geometry={nodes.Blade2Hat.geometry}
        material={materials["BladeMaterial.002"]}
        position={[-0.003, 2.451, 0.916]}
        scale={[0.107, 0.078, 0.107]}
      />
      <mesh
        geometry={nodes.Blade1Hat.geometry}
        material={materials["BladeMaterial.002"]}
        position={[-0.003, 2.451, -0.988]}
        scale={[0.104, 0.076, 0.104]}
      />

      <mesh
        geometry={nodes.BarrelAlcaline.geometry}
        material={nodes.BarrelAlcaline.material}
        position={[1.356, 0.27, 2.848]}
      />
      <mesh
        geometry={nodes.BarrelAcid.geometry}
        material={nodes.BarrelAcid.material}
        position={[2.204, 0.27, 3.091]}
      />

      {/* CallOutText */}
      <CallOutText
          position={[0, 2.9, 0.92]}
          text={`${encoderData?.value + " rad/s" ?? "No data"} `}
          radius={0.05}
        />
        <CallOutText
          position={[0, 2.9, -0.92]}
          text={`${encoderData?.value + " rad/s" ?? "No data"} `}
          radius={0.05}
        />
        <CallOutText
          position={[0, 2.9, 0]}
          text={`${
            switchStatus == null
              ? "No Data"
              : switchStatus.status
              ? "Open"
              : "Closed"
          }`}
        />
        <CallOutText
          position={[1.7, 0.9, 3.2]}
          text={`${
            weightData == null ? "No Data" : weightData.weight + "kg"
          } `}
        />

    </group>
  );
}

useGLTF.preload("./horizontalTankModel/2Pales/horizontalTank2Blades.glb");
